<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <title>Team 3 Project Site</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <section class="page-header">
        <h1 class="project-name">Team 3's Software Project</h1>

        <a href="index.html" class="btn">Home</a>
        <a href="retrospective.html" class="btn">Project Retrospective</a>
        <a href="plan.html" class="btn">Project Plan</a>
        <a href="team.html" class="btn">Team Roster</a>
        <a href="software-design.html" class="btn">Software Design</a>
        <a href="ui-design.html" class="btn">UI Design</a>
    </section>

    <section class="main-content">
        <h1>Project Retrospective</h1>
        <h3>Video Demo</h3>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/NvTMpJkO2PM" frameborder="0" allowfullscreen>
        </iframe>

        <h3>Workflow</h3>
            <p>Throughout the duration of our project, we took measures to ensure that standard git practices were followed. We
            decided to use a feature branch model, where if any major feature was to be added (more than one commit), it was to
            be completed in another branch before being merged into the main development branch. This helped to minimize
            conflictsthat occurred when many features were being added at once and helped to avoid confusion. When the feature
            was completed, it was merged in the development branch and any conflicts that arose were dealt with at the same
            time. As well, when able to, we tried to pull from the server before making any commits on our local branch, to
            help avoid created conflicts.</p>

            <p>The major tool that was utilized for this project was the Gradle build tool. Gradle helped to simplify the
            building, testing and deployment process by automating all the needed steps to perform such tasks. Additionally,
            this allowed our project to more easily manage dependencies, as Gradle would ensure that every dependency was
            installed and using the latest version whenever building the app. By allowing Gradle to perform dependency
            management, this meant that dependency files themselves did not have to be included in our git repository, causing
            the size of the project to be significantly less and avoiding pointless commits regarding changes that occurred to
            a dependency irrelevant to our own code. Additionally, the IDE used by our team - IntelliJ IDE - assisted us in the
            usage of git, code refactoring, and manage our project's gradle configuration.</p>

            <p>In term of the actual stack that our app, a Grails backend was used to provide a web server and a RESTful API to
            our frontend and a React based frontend was used to provide a single-page app experience to our users. The decision
            to use Grails was decided based on the fact that it provided a good all-in-one package to handle backend tasks, as
            well as being powerful enough to implement complex features in the future. The decision to use a React based
            frontend was decided based on the fact that almost all of our app’s HTML elements were dynamic in some way and
            React provided a simple way to implement a complex user interface with minimal code.</p>

            <p>Our team worked well in managing task distributions. Given the nature of our React frontend (where most of our
            code resided), assigning specific people to code different components worked well. Once one or more components were
            developed, typically our group would be together in order to address any questions or concerns with each other when
            the merge was actually performed. This helped to better our workflow and avoid problems due to uncertainty further
            into the development process.</p>

        <h3>MVC &amp; Design Patterns</h3>

            <img src="./image/MVCexample.png" style="width: 600px; height auto;"/>

            <h4>What is the relationship between user interfaces, application logic, and data in your project?</h4>
            <p>In the user interface, a user will begin by logging onto the <i>EmptyMyFridge</i> website through their Google
            account. User authentication is handled in the front-end through Firebase.</p>

            <p>When a user begins a new search, a list of ingredients and dietary preferences is passed as a string from the
            front-end of the program to the back-end. In the back-end, a request is made to the Spoonacular API. Information in
            the back-end is parsed and formatted to be returned to the front-end so the user may see the results.</p>

            <p>After viewing his/her results, a user may choose to “like” a recipe, which will save the recipe details to their
            account page. This is done by using Firebase to store the recipeID associated with each recipe returned by
            Spoonacular. Each time a user returns to his/her account page, the recipes he/she liked will be visible. This is
            done by retrieving the recipeIDs associated with that user though Firebase and passing them to the back-end. The
            Spoonacular API uses the recipeID to return the recipe details to the front-end.</p>

            <p>If a user wishes to browse recipes are popular, an explore page allows the user to see 20 trending recipes. The
            front-end makes a call of a back-end function which calls Spoonacular to return the appropriate recipes. As before,
            the return information is parsed and formatted in the back-end and returned to the front-end.</p>

            <p>The communication between the back-end and the front-end is done using a REST API.</p>

            <h4>Which collection of classes serve as the M, V, and C in MVC?</h4>
            <h4>View</h4>
            Index files in the front-end views handle information that was passed from the user and use it to make a
            call to the back-end for recipe information. When the JSON objects containing the recipes return from the back-end,
            they are processed in the front-end to build the appropriate view.</p>

            <p>This is done by storing the information in the JSON objects into arrays. When components are to be rendered in a
            view, the array is passed to that view and the components handle the individual items of each JSON object in the
            array.</p>

            <h4>Controller</h4>
            The controller class of the project is the Ingredient Controller in the back-end. This class makes all the
            Spoonacular calls required for the project.</p>

            <p>When a request is made by the front-end through the REST API, a subsequent call is made to Spoonacular by taking
            the parameters passed and incorporating them into a specially formatted string. This new string is then passed to
            Spoonacular.</p>

            <p>Since Spoonacular returns JSON nodes of different structures, there exists classes in the controller specifically designed to parse and format the information to build an object of type Recipe</p>

            <h4>Model</h4>
            <p>The model of this project is the Recipe domain class. This class creates an object with the sole purpose of
            immediately casting them into JSON objects for the front-end to use.</p>

            <h4>If you were to start the project again today, what aspects of code organization could be improved in your
            project?</h4>

            <p>If we could legally store the information retrieved from Spoonacular, we would be interested in developing our
            own database in the back-end which could store the Recipe objects directly. When a user likes a recipe, the recipe
            object can be directly associated with the users account, rather than saving only the recipeID. This would reduce
            the number of API calls we would need to make (which, outside of a school setting, each call costs money).</p>

            <p>Developing our own database would also allow us to no longer rely on Firebase for user authentication (though we
            like being able to log in through a google account and feel it is still relevant even if we had our own
            database).</p>

            <p>Building our own database would also allow us to develop our own system of recipe suggesting. This could be done
            by considering which recipes a person likes, what meal types they are, what diet restrictions are imposed, etc. The
            current system only returns popular recipes of any type.</p>

        <h3>Refractor Retrospect</h3>
            <h4>Areas that were strong</h4>
            <p>One area of strength in the object-oriented design of our project was the reusability of React components. Some
            of the components we use in our project are rendered in many places in our app. For example, the RecipeBox and
            RecipeGrid components are used on the recipe results page, the explore recipes page and the user profile page.
            These components are used to display recipes in a grid with the recipe name and an image of the recipe.
            Additionally, the RecipeDetails component was integrated into the the recipe grid. This allowed for the rendering
            of the details to be handled by the RecipeGrid, and not the page of the app itself, despite it appearing to take up
            the entirety of the window, not just inside the RecipeGrid component’s area. This was a major function of our
            application and the ability to reuse these components greatly reduced the amount of work any new pages would
            require. For making changes or fixing bugs with the grid view, code would only have to editted in one location, as
            opposed to three different places. Finally, this allowed views of the grid to stay consistent throughout different
            areas of the app, as the same code would be used.</p>

            <p>Another area of strength in the object-oriented design of the app was the decision to handle the Spoonacular API
            key on our back end. This was good for security in our application because it meant the API key was not directly
            accessible by the user, given as the API key is licensed to the provider only (i.e. our team). As well, Spoonacular
            limits usage of the API requests, so it should not be publicly accessible to prevent abuse or users saving the key
            to use for own purposes.</p>

            <p>Finally, we felt the implementation of our frontend React structure was effective and conventional in that it
            can be modified and understood easily to not only our own team members, but to any other React developer that
            would happen to look at the source code. As well, consistency of programming style and commenting were paid
            attention to to ensure easy readability. Ensuring the proper design of software both in a readability sense and an
            implementation sense is important for efficiency, scalability and ease of altering or adding more features in the
            future.</p>

            <h4>Areas that were weak</h4>
            <p>One area of the project we felt was weak was only storing recipe ID’s in our database. This meant an API call
            was required for each of a user’s saved recipes to gather the information about that recipe. In a commercial
            application, there would be a cost associated with a large number of API calls. Depending on usage rights, storing
            the full information of a user’s saved recipe in our database would save ourselves the extra calls to the
            Spoonacular API. With this method we would have to make occasional requests to retrieve information about the
            recipe, to ensure that any update made to its information is updated in our database as well.</p>

        	<p>While stated above that the reusability of components was taken advantage of when able, we did feel that some
            code used inside of our components were very similar in terms of general logic. For example, the code on the
            frontend that prepares and makes an API request to the IngredientController of our backend is used everywhere that
            makes an API call and each is very similar in terms of structure and data being retrieved. The action of making an
            API request and retrieving data be factored into its own function and reused in each place it was required to save
            rewriting similar code and generally reduce the bulk of each individual component.</p>

        <hr class="footer">
    </section>
</body>
</html>
